17.1 背景
1.请给出程序正确性的定义或解释。
程序执行的结果是实现预期的功能，并且是确定的和可重现的；

我们只能在确定的限制条件下来讨论“正确性”的定义或解释，没有无条件的“正确”。

2.在一个新运行环境中程序行为与原来的预期不一致，是错误吗？
如果预期行为包括明确的运行环境的限定，这就不是错误；否则就是错误；

3.程序并发执行有什么好处和障碍？
共享资源

加速处理

方便管理：模块化

4.什么是原子操作？
原子操作是指一次不存在任何中断或失败的操作，不会出现部分执行的状态。


17.2现实生活中的同步问题
1.家庭采购中的同步问题的5种解决方案的核心思路是什么？举例描述可能的漏洞。
思路的关键点：有人去买，不会重复买；合理的枚举分类；

方案一：先检查，后加相同的标签；漏洞是可能重复采购；

方案二：先加相同的标签，后检查；漏洞是会出现没人去买的情况；

方案三：先加不同的标签，后检查；漏洞是会出现没人去买的情况；

方案四：先加不同的标签，后进行非对称检查；经枚举判断，结果是不会出现漏洞；

方案五：原子操作

2.家庭采购中的同步问题与操作系统中进程同步有什么区别？
操作系统的进程切换比人的操作切换快；

操作系统的进程对外界环境的感知手段比人少；

3.如何通过枚举和分类方法检查同步算法的正确性？
合理定义枚举分类标准是检查同步算法正确性的关键；

4.尝试描述方案四的正确性。
依据谁先加标签和加第二个标签的时间进行情况划分

5.举例说明，互斥、死锁和饥饿的定义是什么？
互斥：一个进程占用资源，其它进程不能使用；

死锁：多个进程各占用部分资源，形成循环等待；

饥饿：其他进程可能轮流占用资源，一个进程一直得不到资源；


17.3 临界区，禁用硬件中断,硬件原子操作同步方法
1.什么是临界区？
操作临界资源的互斥执行代码片段

2.临界区的访问规则是什么？
空闲则入、忙则等待、有限等待、让权等待

3.禁用中断是如何实现对临界区的访问控制的？有什么优缺点？
禁用中断可以阻止其他进程对临界区访问进程的打断；

优点是简单；缺点是无法中断，临界区代码故障可以导致系统崩溃，其他进程可能出现饥饿；

4.Test&Set原子操作是否可以实现Exchange原子操作? Exchange原子操作是否可以实现Test&Set原子操作?
这两条指令在实现原子操作的功能是等价的。


17.4 基于软件的同步方法
1.软件同步方法中的5种解决方案（三种尝试方案、Peterson算法和Eisenberg算法）的核心思路是什么？举例描述可能的漏洞。
方案一：turn 表示允许进入临界区的线程标识； 方案漏洞：交替进入临界区；

方案二：flag[i] 表示线程i是否在临界区； 先判断，后修改变量； 方案漏洞：并发判断后，可能出现同时进入临界区；

方案二：flag[i] 表示线程i想要进入临界区； 先修改变量，后判断； 方案漏洞：并发修改变量后，可能出现都无法进入临界区的情况；

Peterson算法：turn 表示进入临界区的线程标识，flag[i] 表示线程i想要进入临界区； 先修改变量，后判断；后修改者等待； 只适用于两个进程； 方案正确性枚举判断：按写变量的顺序进行情况分类

Eisenberg算法：flag[i] 表示线程i想要进入临界区，turn 表示进入临界区的线程标识（有多个想进入时）； 进入区：先修改flag，后判断是否有多个想进入；后修改者等待； 退出区：修改turn； 适用于多个进程； 方案正确性枚举判断：按写变量flag[i]的顺序和变量turn当前值进行情况分类

2.尝试通过枚举和分类方法检查Peterson算法的正确性。

3.尝试准确描述Eisenberg同步算法，并通过枚举和分类方法检查其正确性。


17.5 高级抽象的同步方法
1.如何证明TS指令和交换指令的等价性？
利用一条指令来实现另一条指令的功能；

2.自旋锁（spinlock）和无忙等待锁是如何实现同步的？它们有什么不同？
自旋锁是基于TS指令实现同步的，进入区的等待是占用CPU的；

无忙等待锁是在自旋锁的基础上加一个等待队列和进程切换，进入区的等待是不占用CPU的；

3.为什么硬件原子操作指令能简化同步算法的实现？
原子操作指令是硬件实现的，与进程数目无关；

缺点是，等待时占用CPU，可能出现饥饿和死锁；